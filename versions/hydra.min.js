/*! Hydra.js v3.8.1 | Date:2014-01-17 | License: https://raw.github.com/tcorral/Hydra.js/master/LICENSE| (c) 2009, 2013
 //@ sourceMappingURL=hydra.min.map
 */

(function (a) {
  "use strict";
  var b = b, c, d = Error, e, f, g, h, i, j = {}, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A;
  f = function (a, b) {
    return typeof a === b
  }, g = function (a, b) {
    return a instanceof b
  }, n = function (a, b) {
    var c = "The module " + a + " is not registered in the system";
    if (b)throw new d(c);
    return c
  }, k = "object", r = "function";
  function B(b) {
    try {
      return g(b, Event)
    } catch (c) {
      if (b.altKey !== a && (b.srcElement || b.target))return o
    }
    return p
  }

  function C(a) {
    var b = p, c = e.jQuery;
    return c && (b = g(a, c)), b
  }

  function D() {
  }

  function E() {
    var a = Math, b = +new Date + "", c = a.floor(999999 * a.random()) + 1;
    return b + "_" + c
  }

  function F(a) {
    var b, c, d = Object.keys;
    if (d)b = d(a).length; else {
      b = 0;
      for (c in a)M(a, c) && b++
    }
    return b
  }

  h = "undefined", A = Object.prototype, e = this, c = e, z = typeof exports === k && typeof module === k && typeof module.exports === k && typeof require === r, l = null, p = !1, o = !0, i = {}, q = "3.8.1", u = p, m = p;
  function G(a) {
    return A.toString.call(a)
  }

  function H(a) {
    return G(a) === "[" + k + " Function]"
  }

  function I(a) {
    return G(a) === "[" + k + " Array]"
  }

  function J(a) {
    u = a
  }

  function K(a) {
    m = a
  }

  function L(a, b) {
    return[].slice.call(a, b || 0)
  }

  function M(a, b) {
    return a.hasOwnProperty(b)
  }

  function N(a, b, c, d) {
    var e, g;
    for (e in b)M(b, e) && (g = b[e], a[e] && f(g, r) && g(a, c, d))
  }

  function O(a, b, c, e, g) {
    var j, k;
    return j = i[b], g && a.isModuleStarted(b) && a.stop(b), f(j, h) ? v.error(new d, n(b)) : (k = V(b), j.instances[c] = k, k.__instance_id__ = c, N(k, a.oModifyInit, e, g), f(e, h) ? k.init() : k.init(e)), k
  }

  function P(a, b) {
    var c;
    for (c in b)M(b, c) && (a[c] = b[c]);
    return a
  }

  function Q(a) {
    var b, c, e, h, i;
    if (null == a || !f(a, k))return a;
    if (B(a) || C(a))return a;
    if (g(a, Date))return b = new Date, b.setTime(a.getTime()), b;
    if (g(a, Array)) {
      for (b = [], e = 0, h = a.length; h > e; e++)c = a[e], b[e] = Q(c);
      return b
    }
    if (g(a, Object)) {
      b = {};
      for (i in a)M(a, i) && (b[i] = Q(a[i]));
      return b
    }
    throw new d("Unable to copy obj! Its type isn't supported.")
  }

  function R(a, b, c, d) {
    a[b] = function (a, b) {
      return function () {
        var d = L(arguments, 0);
        try {
          return b.apply(this, d)
        } catch (e) {
          return v.error(c, a, e), p
        }
      }
    }(b, d)
  }

  y = {global: {}};
  function S(a, b) {
    var c = [], d;
    if (!f(a, h))for (d in a)M(a, d) && d === b && (c = a[d]);
    return c
  }

  x = {subscribers: function (a, b) {
    return S(y[a], b)
  }, _getChannelEvents: function (b, c) {
    return y[b] === a && (y[b] = {}), y[b][c] === a && (y[b][c] = []), y[b][c]
  }, _addSubscribers: function (a, b, c) {
    var d;
    for (d in a)M(a, d) && this.subscribeTo(b, d, a[d], c)
  }, unsubscribeFrom: function (a, b, c) {
    var d = this._getChannelEvents(a, b), e, f = d.length - 1;
    for (; f >= 0; f--)e = d[f], e.subscriber === c && d.splice(f, 1)
  }, subscribeTo: function (a, b, c, d) {
    var e = this._getChannelEvents(a, b);
    e.push({subscriber: d, handler: c})
  }, subscribe: function (b) {
    var c, d = b.events;
    if (!b || d === a)return p;
    for (c in d)M(d, c) && (y[c] === a && (y[c] = {}), this._addSubscribers(d[c], c, b));
    return o
  }, _removeSubscribers: function (a, b) {
    var c = 0, d;
    if (!f(a, h))for (d = a.length - 1; d >= 0; d--)a[d].subscriber === b && (c++, a.splice(d, 1));
    return c
  }, _removeSubscribersPerEvent: function (a, b, c) {
    var d, e, f, g, h = 0;
    for (d in a)M(a, d) && (e = d.split(":"), f = b, g = d, "global" === e[0] && (f = e[0], g = e[1]), h += this._removeSubscribers(y[f][g], c));
    return h
  }, unsubscribe: function (b) {
    var c = 0, d, e = b.events;
    if (!b || e === a)return p;
    for (d in e)M(e, d) && (y[d] === a && (y[d] = {}), c = this._removeSubscribersPerEvent(e[d], d, b));
    return c > 0
  }, _avoidBlockUI: function (a, c, d, e) {
    var f, g = a.concat();
    b(function h() {
      var a = +new Date;
      do f = g.shift(), f.handler.call(f.subscriber, c), u && v.log(d, e, f); while (g.length > 0 && +new Date - a < 50);
      g.length > 0 && b(h, 25)
    }, 25)
  }, publish: function (a, b, c) {
    var d = this.subscribers(a, b).slice(), e = d.length, f = 0, g, h;
    if (0 === e)return p;
    if (h = Q(c), m)this._avoidBlockUI(d, h, a, b); else for (; e > f; f++)g = d[f], g.handler.call(g.subscriber, h), u && v.log(a, b, g);
    return o
  }, reset: function () {
    y = {global: {}}
  }};
  function T(b, d) {
    var g, h, k, l = [], m = {$bus: x, $module: t.module, $log: v, $api: t, $global: e, $doc: e.document || null}, n = [m, j, i], o = n.length, p, q = {mapping: [], dependencies: []}, r = 0;
    for (d = d !== a ? d : i[b].dependencies || [], h = d.length, n = n.concat(c !== e ? [c, e] : [e]), g = 0; h > g; g++)if (k = d[g], f(k, "string")) {
      for (r = 0; o >= r; r++)if (p = n[r], p[k]) {
        l[g] = p[k];
        break
      }
      l[g] === a && (l[g] = null), q.mapping[g] = k
    } else l[g] = k;
    return q.dependencies = l, q
  }

  function U(a, b) {
    var c, d, e = T(a, b);
    return c = i[a].creator.apply(i[a], e.dependencies), c.dependencies = b, c.resolvedDependencies = e.map, c.__module_id__ = a, d = c.init || D, c.__action__ = c.__sandbox__ = x, c.events = c.events || {}, c.init = function () {
      var a = L(arguments, 0).concat(j);
      return x.subscribe(c), d.apply(this, a)
    }, c.handleAction = function (a) {
      var b = this.events[a.type];
      f(b, h) || b.call(this, a)
    }, c.onDestroy = c.onDestroy || c.destroy || function () {
    }, c.destroy = function () {
      this.onDestroy(), x.unsubscribe(c), delete i[a].instances[c.__instance_id__]
    }, c
  }

  function V(a, b) {
    var c, d;
    if (f(i[a], h) && n(a, o), c = U(a, b), !u)for (d in c)M(c, d) && H(c[d]) && R(c, d, a, c[d]);
    return c
  }

  v = e.console || {log: function () {
  }, error: function () {
  }}, w = function () {
    this.__super__ = {}, this.instances = {}
  }, w.prototype = {type: "Module", getInstance: V, oModifyInit: {}, register: function (a, b, c) {
    return H(b) && (c = b, b = [x, t.module, v, t]), i[a] = new s(a, c), i[a].dependencies = b, i[a]
  }, _setSuper: function (a, b) {
    a.__super__ = {}, a.__super__.__instance__ = b, a.__super__.__call__ = function (b, c) {
      var d = this;
      while (M(d, b) === p)d = d.__instance__.__super__;
      return d[b].apply(a, c)
    }
  }, _callInSuper: function (a) {
    return function () {
      var b = L(arguments, 0);
      a.apply(this, b)
    }
  }, _mergeModuleExtended: function (a, b) {
    var c;
    for (c in b)M(b, c) && (!f(a.__super__, h) && H(a[c]) && (a.__super__[c] = this._callInSuper(a[c])), a[c] = b[c])
  }, _mergeModuleBase: function (a, b) {
    var c;
    for (c in b)M(b, c) && "__super__" !== c && (a[c] = b[c])
  }, _merge: function (a, b) {
    var c = {};
    return this._setSuper(c, a), this._mergeModuleBase(c, a), this._mergeModuleExtended(c, b), c
  }, setInstance: function (a, b, c) {
    var d = i[a];
    return d || n(a, o), d.instances[b] = c, d
  }, setVars: function (a) {
    j = f(j, h) ? a : P(j, a)
  }, resetVars: function () {
    j = {}
  }, getVars: function () {
    return P({}, j)
  }, _multiModuleStart: function (a, b, c, d) {
    var e, f, g, h, i, j;
    for (I(b) && (e = b.slice(0)), I(c) && (f = c.slice(0)), I(d) && (g = d.slice(0)), h = 0, i = a.length; i > h; h++)j = a[h], b = e && e[h] || E(), c = f && f[h] || c, d = g && g[h] || d, O(this, j, b, c, d)
  }, _singleModuleStart: function (a, b, c, d) {
    f(b, "string") || (d = c, c = b, b = E()), O(this, a, b, c, d)
  }, start: function (a, b, c, d) {
    var e = I(a);
    e ? this._multiModuleStart(a.slice(0), b, c, d) : this._singleModuleStart(a, b, c, d)
  }, extend: function (a, b, c, d) {
    var e = i[a], g, h;
    return e ? (h = V(a), f(b, r) && (d = b, b = a, c = [x, t.module, t.errorHandler(), t]), f(c, r) && (d = c, c = [x, t.module, t.errorHandler(), t]), c.push(h), g = d.apply(d, c), i[b] = new s(b, function () {
      var a = {};
      return a = P(a, h), a = P(a, g), a = P(a, {__super__: {__call__: function (a, b) {
        return h[a].apply(h, b)
      }}})
    }), i[b].dependencies = c, i[b]) : (v.log(n(a)), l)
  }, decorate: function () {
    return this.extend.apply(this, arguments)
  }, isModuleStarted: function (a, b) {
    var c = p;
    return c = f(b, h) ? !f(i[a], h) && F(i[a].instances) > 0 : !f(i[a], h) && !f(i[a].instances[b], h)
  }, startAll: function () {
    var a, b;
    for (a in i)M(i, a) && (b = i[a], f(b, h) || this.start(a, E()))
  }, _multiModuleStop: function (a) {
    var b, c = a.instances, d;
    for (b in c)M(c, b) && (d = c[b], f(a, h) || f(d, h) || d.destroy());
    a.instances = {}
  }, _singleModuleStop: function (a, b, c) {
    var d = a.instances[c];
    f(a, h) || f(d, h) || (d.destroy(), delete a.instances[c])
  }, stop: function (a, b) {
    var c;
    return c = i[a], f(c, h) ? p : (f(b, h) ? this._multiModuleStop(c) : this._singleModuleStop(c, a, b), o)
  }, _stopOneByOne: function (a, b) {
    var c;
    for (c in a)M(a, c) && this.stop(b, c)
  }, stopAll: function () {
    var a;
    for (a in i)M(i, a) && !f(i[a], h) && this._stopOneByOne(i[a].instances, a)
  }, _delete: function (a) {
    return f(i[a], h) ? p : (delete i[a], o)
  }, remove: function (a) {
    var b = i[a];
    if (f(b, h))return l;
    if (!f(b, h))try {
      return b
    } finally {
      this._delete(a)
    }
    return l
  }};
  function W() {
    return v
  }

  function X(a) {
    v = a
  }

  t = function () {
  }, t.version = q, t.bus = x, t.errorHandler = W, t.setErrorHandler = X, t.module = new w, t.setUnblockUI = K, t.setDebug = J, t.getDebug = function () {
    return u
  }, t.extend = function (a, b) {
    this[a] = f(this[a], h) ? b : P(this[a], b)
  }, t.resolveDependencies = T, t.noConflict = function (a, b, c) {
    return f(this[a], h) ? p : (b[c] = this[a], o)
  }, t.addExtensionBeforeInit = function (a) {
    t.module.oModifyInit = P(t.module.oModifyInit, a)
  }, t.getCopyModules = function () {
    return Q(i)
  }, t.getCopyChannels = function () {
    return Q(y)
  }, t.setNamespace = function (a) {
    c = a
  }, s = function (a, b) {
    if (f(b, h))throw new d("Something goes wrong!");
    this.creator = b, this.instances = {}, this.sModuleId = a
  }, s.prototype = {start: function (a) {
    return t.module.start(this.sModuleId, a), this
  }, extend: function (a, b) {
    return t.module.extend(this.sModuleId, a, b), this
  }, stop: function () {
    return t.module.stop(this.sModuleId), this
  }}, e.Hydra = t, z ? module.exports = t : typeof define !== h && define("hydra", [], function () {
    return t
  })
}).call(this);
//# sourceMappingURL=hydra.min.map